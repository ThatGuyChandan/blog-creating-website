const express = require("express");
const User = require("./models/user");
const Post = require("./models/Post");
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const salt = bcrypt.genSaltSync(10);
const app = express();
const cors = require("cors");
require("dotenv").config();
const nodemailer = require("nodemailer");
const http = require("http");
const { Server } = require("socket.io");
const postRouter = require('./routes/post');
const authRouter = require('./routes/auth');
const profileRouter = require('./routes/profile');
const adminRouter = require('./routes/admin');
const aiRouter = require('./routes/ai');

const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: process.env.Base_URL,
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true,
  },
});

io.on("connection", (socket) => {
  // Optionally log or handle connections
});
app.set("io", io);

// Email setup (configure these environment variables in production)
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST ,
  port: process.env.SMTP_PORT ,
  secure: false, // true for 465, false for other ports
  auth: {
    user: process.env.SMTP_USER ,
    pass: process.env.SMTP_PASS ,
  },
});

async function sendUserStatusEmail(user, status) {
  let subject = '', text = '';
  if (status === 'active') {
    subject = 'Your account has been approved!';
    text = `Hello ${user.username},\n\nYour account on BlogWeb has been approved. You can now log in and start using the site!`;
  } else if (status === 'rejected') {
    subject = 'Your registration was rejected';
    text = `Hello ${user.username},\n\nWe are sorry, but your registration on BlogWeb was rejected. If you believe this is a mistake, please contact the admin.`;
  }
  if (!user.email) return;
  try {
    await transporter.sendMail({
      from: process.env.SMTP_FROM ,
      to: user.email,
      subject,
      text,
    });
  } catch (err) {
    console.error('Failed to send email:', err);
  }
}

async function sendAdminNewUserEmail(user) {
  try {
    await transporter.sendMail({
      from: process.env.SMTP_FROM ,
      to: process.env.ADMIN_EMAIL,
      subject: 'New User Registration Request',
      text: `A new user has registered and is pending approval.\n\nUsername: ${user.username}\nEmail: ${user.email}`,
    });
  } catch (err) {
    console.error('Failed to send admin notification email:', err);
  }
}

app.use(cors({
  origin: process.env.Base_URL,
  credentials: true,
}));

// Ensure preflight requests are handled for all routes
app.options('*', cors({
  origin: process.env.Base_URL,
  credentials: true,
}));

console.log('CORS origin allowed:', process.env.Base_URL);
app.use(express.json());
const jwt = require("jsonwebtoken");
const cookieParser = require("cookie-parser");
const multer = require("multer");
const AWS = require("aws-sdk");
const multerS3 = require("multer-s3");
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const { InferenceClient } = require('@huggingface/inference');

const HF_TOKEN = process.env.HUGGING_FACE_TOKEN;
const client = new InferenceClient(HF_TOKEN);
const aiRateLimit = {};

function adminAuthMiddleware(req, res, next) {
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err || !info) return res.status(401).json({ error: 'Unauthorized' });
    const user = await User.findById(info.id);
    if (!user || user.email !== process.env.ADMIN_EMAIL) {
      return res.status(403).json({ error: 'Access denied: Admins only' });
    }
    req.user = user;
    next();
  });
}

app.post('/ai/suggest-summary', async (req, res) => {
  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const now = Date.now();
  if (aiRateLimit[ip] && now - aiRateLimit[ip] < 10000) {
    return res.status(429).json({ error: 'Too many requests. Please wait a few seconds.' });
  }
  aiRateLimit[ip] = now;

  const { content } = req.body;
  if (!content || content.length < 20) {
    return res.status(400).json({ error: 'Content too short for summary suggestion.' });
  }

  try {
    // Use deepseek-ai/DeepSeek-R1-0528 for summarization
    const prompt = `Return only a short summary (about 30 words) of the following content. No introduction, no prefix, no explanation. Respond with ONLY the summary text:\n\n${content}`;
    const response = await client.chatCompletion({
      provider: "fireworks-ai",
    model: "meta-llama/Llama-3.1-8B-Instruct",
      messages: [
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 100
    });
    let summary = response.choices?.[0]?.message?.content?.trim() || '';
    // Remove any leading/trailing whitespace or newlines
    summary = summary.replace(/^\s+|\s+$/g, '');
    if (!summary) {
      return res.status(500).json({ error: 'No summary generated by AI.' });
    }
    return res.json({ summary });
  } catch (err) {
    console.error('AI summary suggestion error:', err);
    return res.status(500).json({ error: 'Failed to generate summary.' });
  }
});

app.post('/ai/suggest-title', async (req, res) => {
  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const now = Date.now();
  if (aiRateLimit[ip] && now - aiRateLimit[ip] < 10000) {
    return res.status(429).json({ error: 'Too many requests. Please wait a few seconds.' });
  }
  aiRateLimit[ip] = now;

  const { content } = req.body;
  if (!content || content.length < 20) {
    return res.status(400).json({ error: 'Content too short for title suggestion.' });
  }

  try {
    // Use deepseek-ai/DeepSeek-R1-0528 for title generation
    const prompt = `Return only a catchy blog post title (maximum 8 words) based on the following content. Do not explain, do not roleplay, do not prefix anything. Respond with ONLY the title. No \"AI Title\", no thinking, no commentary. Just the plain title:\n\n${content}`;
    const response = await client.chatCompletion({
      provider: "fireworks-ai",
    model: "meta-llama/Llama-3.1-8B-Instruct",
      messages: [
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 24
    });
    let title = response.choices?.[0]?.message?.content?.trim() || '';
    // Post-process: take first 8 words, remove trailing punctuation
    title = title.split(/\s+/).slice(0, 8).join(' ').replace(/[.,;:!?-]+$/, '');
    if (!title) {
      return res.status(500).json({ error: 'No title generated by AI.' });
    }
    return res.json({ title });
  } catch (err) {
    console.error('AI title suggestion error:', err);
    return res.status(500).json({ error: 'Failed to generate title.' });
  }
});

// AWS S3 configuration
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION,
});

function deleteS3Image(imageUrl) {
  if (!imageUrl) return;
  // Extract the S3 key from the URL
  const urlParts = imageUrl.split("/");
  const key = urlParts.slice(3).join("/"); // works for standard S3 URLs
  const params = {
    Bucket: process.env.AWS_S3_BUCKET_NAME,
    Key: key,
  };
  s3.deleteObject(params, (err, data) => {
    if (err) {
      console.error("Failed to delete image from S3:", err);
    }
  });
}

const uploadMiddelware = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.AWS_S3_BUCKET_NAME,
    // acl: "public-read", // Remove this line for buckets with ACLs disabled
    metadata: function (req, file, cb) {
      cb(null, { fieldName: file.fieldname });
    },
    key: function (req, file, cb) {
      const ext = file.originalname.split(".").pop();
      cb(null, Date.now() + "-" + file.originalname);
    },
  }),
});

mongoose
  .connect(process.env.MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("Connected to MongoDB");
  })
  .catch((err) => {
    console.error("Error connecting to MongoDB:", err);
  });
app.use(cookieParser());
app.use("/uploads", express.static(__dirname + "/uploads"));
app.use('/post', postRouter);
app.use('/auth', authRouter);
app.use('/profile', profileRouter);
app.use('/admin', adminRouter);
app.use('/ai', aiRouter);

const port = process.env.PORT || 4000;
server.listen(port, '0.0.0.0', () => {
  console.log(`Server is listening on port ${port}`);
});

// npm i bcryptjs cookie-parser cors dotenv express jsonwebtoken mongodb mongoose multer nodemon
