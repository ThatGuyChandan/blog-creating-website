const express = require("express");
const User = require("./models/user");
const Post = require("./models/Post");
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const salt = bcrypt.genSaltSync(10);
const app = express();
const cors = require("cors");
require("dotenv").config();
const nodemailer = require("nodemailer");

// Email setup (configure these environment variables in production)
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST ,
  port: process.env.SMTP_PORT ,
  secure: false, // true for 465, false for other ports
  auth: {
    user: process.env.SMTP_USER ,
    pass: process.env.SMTP_PASS ,
  },
});

async function sendUserStatusEmail(user, status) {
  let subject = '', text = '';
  if (status === 'active') {
    subject = 'Your account has been approved!';
    text = `Hello ${user.username},\n\nYour account on BlogWeb has been approved. You can now log in and start using the site!`;
  } else if (status === 'rejected') {
    subject = 'Your registration was rejected';
    text = `Hello ${user.username},\n\nWe are sorry, but your registration on BlogWeb was rejected. If you believe this is a mistake, please contact the admin.`;
  }
  if (!user.email) return;
  try {
    await transporter.sendMail({
      from: process.env.SMTP_FROM ,
      to: user.email,
      subject,
      text,
    });
  } catch (err) {
    console.error('Failed to send email:', err);
  }
}

async function sendAdminNewUserEmail(user) {
  try {
    await transporter.sendMail({
      from: process.env.SMTP_FROM ,
      to: process.env.ADMIN_EMAIL,
      subject: 'New User Registration Request',
      text: `A new user has registered and is pending approval.\n\nUsername: ${user.username}\nEmail: ${user.email}`,
    });
  } catch (err) {
    console.error('Failed to send admin notification email:', err);
  }
}

app.use(cors({
  origin: process.env.Base_URL,
  credentials: true,
}));
app.use(express.json());
const jwt = require("jsonwebtoken");
const cookieParser = require("cookie-parser");
const multer = require("multer");
const AWS = require("aws-sdk");
const multerS3 = require("multer-s3");
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
const { InferenceClient } = require('@huggingface/inference');

const HF_TOKEN = process.env.HUGGING_FACE_TOKEN;
const client = new InferenceClient(HF_TOKEN);
const aiRateLimit = {};

function adminAuthMiddleware(req, res, next) {
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err || !info) return res.status(401).json({ error: 'Unauthorized' });
    const user = await User.findById(info.id);
    if (!user || user.email !== process.env.ADMIN_EMAIL) {
      return res.status(403).json({ error: 'Access denied: Admins only' });
    }
    req.user = user;
    next();
  });
}

app.post('/ai/suggest-summary', async (req, res) => {
  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const now = Date.now();
  if (aiRateLimit[ip] && now - aiRateLimit[ip] < 10000) {
    return res.status(429).json({ error: 'Too many requests. Please wait a few seconds.' });
  }
  aiRateLimit[ip] = now;

  const { content } = req.body;
  if (!content || content.length < 20) {
    return res.status(400).json({ error: 'Content too short for summary suggestion.' });
  }

  try {
    // Use deepseek-ai/DeepSeek-R1-0528 for summarization
    const prompt = `Return only a short summary (about 30 words) of the following content. No introduction, no prefix, no explanation. Respond with ONLY the summary text:\n\n${content}`;
    const response = await client.chatCompletion({
      provider: "fireworks-ai",
    model: "meta-llama/Llama-3.1-8B-Instruct",
      messages: [
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 100
    });
    let summary = response.choices?.[0]?.message?.content?.trim() || '';
    // Remove any leading/trailing whitespace or newlines
    summary = summary.replace(/^\s+|\s+$/g, '');
    if (!summary) {
      return res.status(500).json({ error: 'No summary generated by AI.' });
    }
    return res.json({ summary });
  } catch (err) {
    console.error('AI summary suggestion error:', err);
    return res.status(500).json({ error: 'Failed to generate summary.' });
  }
});

app.post('/ai/suggest-title', async (req, res) => {
  const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
  const now = Date.now();
  if (aiRateLimit[ip] && now - aiRateLimit[ip] < 10000) {
    return res.status(429).json({ error: 'Too many requests. Please wait a few seconds.' });
  }
  aiRateLimit[ip] = now;

  const { content } = req.body;
  if (!content || content.length < 20) {
    return res.status(400).json({ error: 'Content too short for title suggestion.' });
  }

  try {
    // Use deepseek-ai/DeepSeek-R1-0528 for title generation
    const prompt = `Return only a catchy blog post title (maximum 8 words) based on the following content. Do not explain, do not roleplay, do not prefix anything. Respond with ONLY the title. No \"AI Title\", no thinking, no commentary. Just the plain title:\n\n${content}`;
    const response = await client.chatCompletion({
      provider: "fireworks-ai",
    model: "meta-llama/Llama-3.1-8B-Instruct",
      messages: [
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 24
    });
    let title = response.choices?.[0]?.message?.content?.trim() || '';
    // Post-process: take first 8 words, remove trailing punctuation
    title = title.split(/\s+/).slice(0, 8).join(' ').replace(/[.,;:!?-]+$/, '');
    if (!title) {
      return res.status(500).json({ error: 'No title generated by AI.' });
    }
    return res.json({ title });
  } catch (err) {
    console.error('AI title suggestion error:', err);
    return res.status(500).json({ error: 'Failed to generate title.' });
  }
});

// AWS S3 configuration
const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION,
});

function deleteS3Image(imageUrl) {
  if (!imageUrl) return;
  // Extract the S3 key from the URL
  const urlParts = imageUrl.split("/");
  const key = urlParts.slice(3).join("/"); // works for standard S3 URLs
  const params = {
    Bucket: process.env.AWS_S3_BUCKET_NAME,
    Key: key,
  };
  s3.deleteObject(params, (err, data) => {
    if (err) {
      console.error("Failed to delete image from S3:", err);
    }
  });
}

const uploadMiddelware = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.AWS_S3_BUCKET_NAME,
    // acl: "public-read", // Remove this line for buckets with ACLs disabled
    metadata: function (req, file, cb) {
      cb(null, { fieldName: file.fieldname });
    },
    key: function (req, file, cb) {
      const ext = file.originalname.split(".").pop();
      cb(null, Date.now() + "-" + file.originalname);
    },
  }),
});

mongoose
  .connect(process.env.MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("Connected to MongoDB");
  })
  .catch((err) => {
    console.error("Error connecting to MongoDB:", err);
  });
app.use(cookieParser());
app.use("/uploads", express.static(__dirname + "/uploads"));

//register
app.post("/register", async (req, res) => {
  const { username, password, email } = req.body;
  try {
    const userDoc = await User.create({
      username,
      password: bcrypt.hashSync(password, salt),
      email,
      status: 'pending',
    });
    await sendAdminNewUserEmail(userDoc);
    res.status(201).json({ message: 'Registration request submitted. Await admin approval.', user: { username: userDoc.username, email: userDoc.email } });
  } catch (error) {
    console.error(error);
    let msg = 'Failed to register';
    if (error.code === 11000) {
      if (error.keyPattern && error.keyPattern.email) msg = 'Email already in use';
      else if (error.keyPattern && error.keyPattern.username) msg = 'Username already in use';
    }
    res.status(400).json({ error: msg });
  }
});
//login
app.post("/login", async (req, res) => {
  const { username, password } = req.body;

  const userDoc = await User.findOne({ username });

  if (!userDoc) {
    res.status(400).json({ error: "User not found" });
    return;
  }

  if (userDoc.status === 'pending') {
    return res.status(403).json({ error: "Your account is pending admin approval." });
  }
  if (userDoc.status === 'rejected') {
    return res.status(403).json({ error: "Your registration was rejected. Please contact the admin." });
  }

  const passOk = bcrypt.compareSync(password, userDoc.password);
  if (passOk) {
    // Set JWT to expire in 1 hour
    jwt.sign(
      { username, id: userDoc._id },
      process.env.JWT_SECRET,
      { expiresIn: "1h" },
      (err, token) => {
        if (err) throw err;
        res.cookie("token", token, {
          httpOnly: true,
          secure: true, // must be true for HTTPS
          sameSite: "none", // must be 'none' for cross-site cookies
          maxAge: 60 * 60 * 1000, // 1 hour in ms
        }).json({
          id: userDoc._id,
          username: userDoc.username,
          email: userDoc.email,
        });
      }
    );
  } else {
    res.status(400).json({ error: "Password or username is wrong" });
  }
});
//profile
app.get("/profile", (req, res) => {
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err) {
      res.status(401).json({ error: "Unauthorized" });
    } else {
      const userDoc = await User.findById(info.id);
      if (!userDoc) return res.status(404).json({ error: "User not found" });
      res.json({
        id: userDoc._id,
        username: userDoc.username,
        email: userDoc.email,
      });
    }
  });
});
//logout
app.post("/logout", (req, res) => {
  res.cookie("token", "", {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 0,
  }).json("ok");
});
//create post
app.post("/post", (req, res, next) => {
  uploadMiddelware.single("file")(req, res, function (err) {
    if (err) {
      console.error("Upload error:", err);
      return res.status(400).json({ error: err.message || "File upload failed" });
    }
    // Remove strict file requirement: allow post without image
    // if (!req.file) {
    //   return res.status(400).json({ error: "File not uploaded" });
    // }
    const fileUrl = req.file ? req.file.location : null;
    const { token } = req.cookies;
    jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
      if (err) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      try {
        const { title, summary, content } = req.body;
        if (!title || !summary || !content) {
          return res.status(400).json({ error: "All fields are required." });
        }
        const postDoc = await Post.create({
          title,
          summary,
          content,
          cover: fileUrl, // will be null if no image
          author: info.id,
        });
        res.json({ postDoc });
      } catch (error) {
        console.error("Post creation error:", error);
        res.status(400).json({ error: error.message || "Failed to create post" });
      }
    });
  });
});
//edit post
app.put("/post", uploadMiddelware.single("file"), async (req, res) => {
  let fileUrl = null;
  if (req.file) {
    fileUrl = req.file.location;
  }
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err) throw err;
    const { id, title, summary, content } = req.body;
    const postDoc = await Post.findById(id);
    const isAuthor = JSON.stringify(postDoc.author) === JSON.stringify(info.id);
    if (!isAuthor) {
      return res.status(400).json("you are not the author");
    }
    // If a new image is uploaded, delete the old one from S3
    if (fileUrl && postDoc.cover && postDoc.cover !== fileUrl) {
      deleteS3Image(postDoc.cover);
    }
    await postDoc.updateOne({
      title,
      summary,
      content,
      cover: fileUrl ? fileUrl : postDoc.cover,
    });
    res.json(postDoc);
  });
});

app.get("/post", async (req, res) => {
  try {
    res.json(
      await Post.find()
        .populate("author", ["username"])
        .sort({ createdAt: -1 })
        .limit(20)
    );
  } catch (error) {
    console.error("Error fetching posts:", error);
    res.status(500).json({ error: "Failed to fetch posts" });
  }
});

app.get("/post/:id", async (req, res) => {
  const { id } = req.params;
  const postDoc = await Post.findById(id).populate("author", ["username"]);
  res.json(postDoc);
});

// Delete post by ID (author only)
app.delete("/post/:id", async (req, res) => {
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err) return res.status(401).json({ error: "Unauthorized" });
    const { id } = req.params;
    try {
      const post = await Post.findById(id);
      if (!post) return res.status(404).json({ error: "Post not found" });
      if (String(post.author) !== String(info.id)) {
        return res.status(403).json({ error: "You are not the author" });
      }
      // Delete the image from S3 if it exists
      if (post.cover) {
        deleteS3Image(post.cover);
      }
      await Post.findByIdAndDelete(id);
      res.json({ success: true });
    } catch (e) {
      res.status(400).json({ error: "Failed to delete post" });
    }
  });
});

// Update profile (username/password)
app.put("/profile", async (req, res) => {
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err) return res.status(401).json({ error: "Unauthorized" });
    const { username, password } = req.body;
    try {
      const userDoc = await User.findById(info.id);
      if (!userDoc) return res.status(404).json({ error: "User not found" });
      if (username && username !== userDoc.username) {
        // Check if username is taken
        const existing = await User.findOne({ username });
        if (existing) return res.status(400).json({ error: "Username already taken" });
        userDoc.username = username;
      }
      if (password && password.length > 0) {
        userDoc.password = bcrypt.hashSync(password, salt);
      }
      await userDoc.save();
      res.json({ id: userDoc._id, username: userDoc.username });
    } catch (e) {
      res.status(400).json({ error: "Failed to update profile" });
    }
  });
});

// Confirm password for profile update
app.post("/profile", async (req, res) => {
  const { token } = req.cookies;
  jwt.verify(token, process.env.JWT_SECRET, {}, async (err, info) => {
    if (err) return res.status(401).json({ error: "Unauthorized" });
    const { password } = req.body;
    try {
      const userDoc = await User.findById(info.id);
      if (!userDoc) return res.status(404).json({ error: "User not found" });
      const passOk = bcrypt.compareSync(password, userDoc.password);
      if (!passOk) return res.status(401).json({ error: "Incorrect password" });
      res.json({ success: true });
    } catch (e) {
      res.status(400).json({ error: "Failed to confirm password" });
    }
  });
});

// --- Admin Endpoints ---
// List all users (for admin panel)
app.get('/admin/users', adminAuthMiddleware, async (req, res) => {
  try {
    const users = await User.find({}, '-password'); // Exclude password
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Approve user
app.post('/admin/users/:id/approve', adminAuthMiddleware, async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, { status: 'active' }, { new: true });
    if (!user) return res.status(404).json({ error: 'User not found' });
    await sendUserStatusEmail(user, 'active');
    res.json({ message: 'User approved', user });
  } catch (err) {
    res.status(500).json({ error: 'Failed to approve user' });
  }
});

// Reject user
app.post('/admin/users/:id/reject', adminAuthMiddleware, async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, { status: 'rejected' }, { new: true });
    if (!user) return res.status(404).json({ error: 'User not found' });
    await sendUserStatusEmail(user, 'rejected');
    res.json({ message: 'User rejected', user });
  } catch (err) {
    res.status(500).json({ error: 'Failed to reject user' });
  }
});


const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`Server is listening on port ${port}`);
});
// npm i bcryptjs cookie-parser cors dotenv express jsonwebtoken mongodb mongoose multer nodemon
